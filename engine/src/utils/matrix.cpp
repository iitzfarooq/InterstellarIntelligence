#include "matrix.h"

Matrix::Matrix(std::size_t rows, std::size_t cols, float fill)
    : m(rows), n(cols), data_(rows * cols, fill) {}

float& Matrix::operator()(std::size_t i, std::size_t j) {
    return data_[i * n + j];
}

const float& Matrix::operator()(std::size_t i, std::size_t j) const {
    return data_[i * n + j];
}

Matrix Matrix::T() const {
    Matrix result(n, m, 0.0f);
    for (std::size_t i = 0; i < m; ++i) {
        for (std::size_t j = 0; j < n; ++j) {
            result(j, i) = (*this)(i, j);
        }
    }
    return result;
}

// generated by Copilot
size_t Matrix::hash() const {
    size_t seed = 0;
    for (const auto& val : data_) {
        seed ^= std::hash<float>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }
    seed ^= std::hash<std::size_t>()(m) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    seed ^= std::hash<std::size_t>()(n) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    return seed;
}

float Matrix::trace() const {
    if (m != n) {
        throw std::invalid_argument("Trace is only defined for square matrices");
    }

    float tr = 0.0f;
    for (std::size_t i = 0; i < m; ++i) {
        tr += (*this)(i, i);
    }
    return tr;
}

Matrix scale(const Matrix& mat, float scalar) {
    Matrix result(mat.rows(), mat.cols(), 0.0f);
    for (std::size_t i = 0; i < mat.rows(); ++i) {
        for (std::size_t j = 0; j < mat.cols(); ++j) {
            result(i, j) = mat(i, j) * scalar;
        }
    }
    return result;
}

Matrix add(const Matrix& a, const Matrix& b) {
    Matrix result(a.rows(), a.cols(), 0.0f);
    for (std::size_t i = 0; i < a.rows(); ++i) {
        for (std::size_t j = 0; j < a.cols(); ++j) {
            result(i, j) = a(i, j) + b(i, j);
        }
    }
    return result;
}

Matrix mul(const Matrix& a, const Matrix& b) {
    if (a.cols() != b.rows()) {
        throw std::invalid_argument("Matrix dimensions do not match for multiplication");
    }
    Matrix result(a.rows(), b.cols(), 0.0f);
    for (std::size_t i = 0; i < a.rows(); ++i) {
        for (std::size_t j = 0; j < b.cols(); ++j) {
            for (std::size_t k = 0; k < a.cols(); ++k) {
                result(i, j) += a(i, k) * b(k, j);
            }
        }
    }
    return result;
}

Matrix operator*(const Matrix& mat, float scalar) {
    return scale(mat, scalar);
}

Matrix operator+(const Matrix& a, const Matrix& b) {
    return add(a, b);
}

Matrix operator*(const Matrix& a, const Matrix& b) {
    return mul(a, b);
}

Matrix toHomogeneous(const Matrix& mat) {
    if (mat.rows() != 2 || mat.cols() != 1) {
        throw std::invalid_argument("Input matrix must be of size 2x1");
    }

    Matrix result(3, 1, 0.0f);
    result(0, 0) = mat(0, 0);
    result(1, 0) = mat(1, 0);
    result(2, 0) = 1.0f;

    return result;
}

Matrix fromHomogeneous(const Matrix& mat) {
    if (mat.rows() != 3 || mat.cols() != 1) {
        throw std::invalid_argument("Input matrix must be of size 3x1");
    }

    Matrix result(2, 1, 0.0f);
    float w = mat(2, 0);
    if (w == 0.0f) {
        throw std::invalid_argument("Homogeneous coordinate w cannot be zero");
    }
    result(0, 0) = mat(0, 0) / w;
    result(1, 0) = mat(1, 0) / w;

    return result;
}

Matrix eye(std::size_t size) {
    Matrix result(size, size, 0.0f);
    for (std::size_t i = 0; i < size; ++i) {
        result(i, i) = 1.0f;
    }
    return result;
}

Matrix zero(std::size_t rows, std::size_t cols) {
    return Matrix(rows, cols, 0.0f);
}

Matrix translate2d(float tx, float ty) {
    Matrix result = eye(3);
    result(0, 2) = tx;
    result(1, 2) = ty;
    return result;
}

Matrix rotate2d(float angle_rad) {
    Matrix result = eye(3);
    float c = std::cos(angle_rad);
    float s = std::sin(angle_rad);
    result(0, 0) = c;
    result(0, 1) = -s;
    result(1, 0) = s;
    result(1, 1) = c;
    return result;
}

Matrix scale2d(float sx, float sy) {
    Matrix result = eye(3);
    result(0, 0) = sx;
    result(1, 1) = sy;
    return result;
}
#include "matrix.h"

Matrix::Matrix(size_t rows, size_t cols, f64 fill)
    : m(rows), n(cols), data_(rows * cols, fill) {}

Matrix::Matrix(size_t rows, size_t cols, const std::initializer_list<f64>& values) 
    : m(rows), n(cols), data_(values) {
    req(values.size() == rows * cols, "Initializer list size does not match matrix dimensions");
}

Matrix::Matrix(size_t rows, size_t cols, const std::vector<f64>& values) 
    : m(rows), n(cols), data_(values) {
    req(values.size() == rows * cols, "Vector size does not match matrix dimensions");
}

f64& Matrix::operator()(size_t i, size_t j) {
    return data_[i * n + j];
}

const f64& Matrix::operator()(size_t i, size_t j) const {
    return data_[i * n + j];
}

Matrix Matrix::T() const {
    Matrix result(n, m, 0.0f);
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            result(j, i) = (*this)(i, j);
        }
    }
    return result;
}

// generated by Copilot
size_t Matrix::hash() const {
    size_t seed = 0;
    for (const auto& val : data_) {
        seed ^= std::hash<f64>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }
    seed ^= std::hash<size_t>()(m) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    seed ^= std::hash<size_t>()(n) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    return seed;
}

f64 Matrix::trace() const {
    if (m != n) {
        throw std::invalid_argument("Trace is only defined for square matrices");
    }

    f64 tr = 0.0f;
    for (size_t i = 0; i < m; ++i) {
        tr += (*this)(i, i);
    }
    return tr;
}

Matrix Matrix::scale(const Matrix& mat, f64 scalar) {
    Matrix result(mat.rows(), mat.cols(), 0.0f);
    for (size_t i = 0; i < mat.rows(); ++i) {
        for (size_t j = 0; j < mat.cols(); ++j) {
            result(i, j) = mat(i, j) * scalar;
        }
    }
    return result;
}

Matrix Matrix::add(const Matrix& a, const Matrix& b) {
    Matrix result(a.rows(), a.cols(), 0.0f);
    for (size_t i = 0; i < a.rows(); ++i) {
        for (size_t j = 0; j < a.cols(); ++j) {
            result(i, j) = a(i, j) + b(i, j);
        }
    }
    return result;
}

Matrix Matrix::mul(const Matrix& a, const Matrix& b) {
    if (a.cols() != b.rows()) {
        throw std::invalid_argument("Matrix dimensions do not match for multiplication");
    }
    Matrix result(a.rows(), b.cols(), 0.0f);
    for (size_t i = 0; i < a.rows(); ++i) {
        for (size_t j = 0; j < b.cols(); ++j) {
            for (size_t k = 0; k < a.cols(); ++k) {
                result(i, j) += a(i, k) * b(k, j);
            }
        }
    }
    return result;
}

Matrix operator*(const Matrix& mat, f64 scalar) {
    return Matrix::scale(mat, scalar);
}

Matrix operator*(f64 scalar, const Matrix& mat) {
    return Matrix::scale(mat, scalar);
}

Matrix operator+(const Matrix& a, const Matrix& b) {
    return Matrix::add(a, b);
}

Matrix operator-(const Matrix& a, const Matrix& b) {
    return Matrix::add(a, Matrix::scale(b, -1.0f));
}

Matrix operator*(const Matrix& a, const Matrix& b) {
    return Matrix::mul(a, b);
}

Matrix Matrix::toHomogeneous(const Matrix& mat) {
    if (mat.rows() != 2 || mat.cols() != 1) {
        throw std::invalid_argument("Input matrix must be of size 2x1");
    }

    Matrix result(3, 1, 0.0f);
    result(0, 0) = mat(0, 0);
    result(1, 0) = mat(1, 0);
    result(2, 0) = 1.0f;

    return result;
}

Matrix Matrix::fromHomogeneous(const Matrix& mat) {
    if (mat.rows() != 3 || mat.cols() != 1) {
        throw std::invalid_argument("Input matrix must be of size 3x1");
    }

    Matrix result(2, 1, 0.0f);
    f64 w = mat(2, 0);
    if (w == 0.0f) {
        throw std::invalid_argument("Homogeneous coordinate w cannot be zero");
    }
    result(0, 0) = mat(0, 0) / w;
    result(1, 0) = mat(1, 0) / w;

    return result;
}

Matrix eye(size_t size) {
    Matrix result(size, size, 0.0f);
    for (size_t i = 0; i < size; ++i) {
        result(i, i) = 1.0f;
    }
    return result;
}

Matrix zero(size_t rows, size_t cols) {
    return Matrix(rows, cols, 0.0f);
}

Matrix Matrix::translate2d(f64 tx, f64 ty) {
    Matrix result = eye(3);
    result(0, 2) = tx;
    result(1, 2) = ty;
    return result;
}

Matrix Matrix::rotate2d(f64 angle_rad) {
    Matrix result = eye(3);
    f64 c = std::cos(angle_rad);
    f64 s = std::sin(angle_rad);
    result(0, 0) = c;
    result(0, 1) = -s;
    result(1, 0) = s;
    result(1, 1) = c;
    return result;
}

Matrix Matrix::scale2d(f64 sx, f64 sy) {
    Matrix result = eye(3);
    result(0, 0) = sx;
    result(1, 1) = sy;
    return result;
}